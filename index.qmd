---
title: "Bayesian VAR Forecast of Macroeconomic and Financial Variables"
author: "Carl Buan"

execute:
  echo: true

# format:
#   pdf:
#     fontfamily: cmbright
#     geometry: margin=1.5cm
format:
  html:
    toc: true
    toc-location: left
---

> **Abstract**

# Research question
Past financial crises such as in 2008 have shown the severe impact that financial conditions can have on the real economy with crashes followed by increasing unemployment and decreased economic activity. This research project's aim to analyze the forecasting performance of macroeconomic variables by including financial variables.
 
Thus the research question can be stated as: Will including financial variables improve the forecasting performance of the real economy?

## Motivation

Traditional macroeconomic modelling often exclude financial markets, as the effects from the financial nominal variables on real variables are deemed insignificant per the classical dichotomy in macroeconomics. However, as earlier studies have shown and the descriptive analysis following this will illustrate, changes in the financial sector can spill over to economic activity. Therefore, it could help explaining the real economy, which could translate to improved forecasting performance.

As both monetary and fiscal policy is not only based on current economic conditions but also expectations regarding the future, it is essential to be able to generate accurate predictions of economic activity and inflation in the future. 

# Data and its properties
My choice of variables is somewhat inspired by papers like Peersman et. al (2017), who perform SVAR analyses of the ECB's monetary policy, however, I am instead interested in examining the forecasting ability of macroeconomic variables combined with financial for the euro area. 
As forecasts are often short-term forecasts of the immediate future, data frequency has to be high, hence all data used in this analysis is monthly.

The economic variables used in this analysis are then (Note that this will be expanded to include several other macroeconomic variables reflecting the economy):

To model the economic activity in the euro area, I use the Industrial Production as proxy for the movements in the Gross Domestic Product (GDP). If I instead opted to use GDP as a variable directly, I would have been required to apply temporal disaggregation, as GDP is tracked quarterly.

The price level in the euro area is included as the Harmonized Index of Consumer Prices (HICP), which measures the price level and inflation across the euro area. Including the price level is important, as it is a major concern for policy makers and it will affect the economic activity and be affected by financial conditions. The base year of the HICP is 2015.

Additionally, I include unemployment in the euro area, as it is both an indicator of economic activity and current expectations to the future. Hence, unemployment serves as an important variable to include when modelling the economy.

I chose to include financial stress, which is measured by composite indicator variable for systemic stress (CISS) in the euro area, as financial conditions and markets highly affects the economic activity, inflation and unemployment.

Finally, I include the M1 money supply in the euro area.

The used time series are collected from the ECB's data warehouse with the chosen time period 01.01.2003 to 2023.12.01. I use the package **ecb** to collect the data.

## Descriptive analysis
The five variables are visualized in @fig-tsplots, where I have taken the logarithm to all variables except from the indicator variable CISS. Inflation and M1 money supply seem to follow an upwards trend, while industrial production, financial stress and unemployment all seem to follow each other, such that industrial production is negative correlated with unemployment and financial stress. Intuitively it makes sense that economic activity decreases with increasing unemployment or stress and uncertainty in the financial sector.

```{r package load}
#| echo: false
#| message: false
#| warning: false
#| results: hide

  
library(dplyr)
library(tidyr)
library(ggplot2)
library(ecb)
library(gridExtra)
library(bsvars)
library(lubridate)
library(tseries)

```

```{r Downloading and readying data}
#| echo: false
#| message: false
#| warning: false
#| results: hide


rm(list = ls())

# Downloading Data
start_date_m <- "2003-01" 
end_date_m <- "2023-12"

# Define the datasets
series_info <- list(
  hicp = "ICP.M.U2.Y.000000.3.INX",
  ciss = "CISS.M.U2.Z0Z.4F.EC.SOV_EW.IDX",
  ip = "STS.M.I8.Y.PROD.NS0010.4.000",
  un = "LFSI.M.I9.S.UNEHRT.TOTAL0.15_74.T",
  m1 = "BSI.M.U2.Y.V.M10.X.1.U2.2300.Z01.E"
)

# Making function to collect data
prepare_data <- function(series_id, name, start_date, end_date) {
  get_data(series_id, filter = list(startPeriod = start_date, endPeriod = end_date)) |>
    transmute(obstime, !!name := obsvalue)
}

# Collecting data
datasets <- lapply(names(series_info), function(name) {
  prepare_data(series_info[[name]], name, start_date_m, end_date_m)
})

# Merge all datasets by 'obstime'
Data <- Reduce(function(x, y) left_join(x, y, by = "obstime"), datasets)

Data <- Data |>
  mutate(across(c(2, 4, 6), ~log(.)))

# Convert 'obstime' to Date format
Data$obstime <- as.Date(paste0(Data$obstime, "-01"))

```

```{r Plotting data}
#| echo: false
#| message: false
#| warning: false
#| results: hide


# Define the plot configurations
plot_settings <- list(
  list(name = "hicp", title = "Inflation", ylab = "LOG(HICP)"),
  list(name = "ip", title = "Industrial production", ylab = "LOG(IP)"),
  list(name = "ciss", title = "Financial Stress", ylab = "CISS"),
  list(name = "un", title = "Unemployment", ylab = "UN"),
  list(name = "m1", title = "M1 - Money Stock", ylab = "M1")
)

# Create the plots
plots <- lapply(plot_settings, function(setting) {
  ggplot(Data, aes_string(x = "obstime", y = setting$name)) +
    geom_line() +
    labs(x = "", y = setting$ylab, title = setting$title) +
    theme_bw() +
    theme(
      panel.border = element_rect(colour = "black", fill=NA),  
      panel.grid.major = element_blank(),  
      panel.grid.minor = element_blank(),  
      plot.background = element_blank(),  
      plot.title = element_text(hjust = 0.5)  
    )
})


```

```{r Plotting the variables}
#| echo: false
#| message: false
#| warning: false
#| label: fig-tsplots
#| fig-cap: Plots of time series

grid.arrange(grobs = plots, ncol = 2)
```

## Autocorrelation in the variables

Additionally, I check for autocorrelation in the time series in @fig-acf and @fig-pacf, where there is clearly a high degree of memory in the variables.

```{r ACF and PACF}
#| echo: false
#| message: false
#| warning: false
#| label: fig-acf
#| fig-cap: Autocorrelation plots for the variables
Data <- as.ts(Data)

par(mfrow = c(2, 3))

variable_names <- c("hicp", "ip", "ciss", "un", "m1")

# Loop through the columns and create ACF plots
for (i in seq_along(variable_names)) {
  # Compute and plot ACF
  acf(Data[, i], main = paste("ACF for", variable_names[i]))
}
  
```

```{r PACF}
#| echo: false
#| message: false
#| warning: false
#| label: fig-pacf
#| fig-cap: Partical autocorrelation plots for the variables

par(mfrow = c(2, 3))
for (i in seq_along(variable_names)) {
  # Compute and plot PACF
  pacf(Data[, i], main = paste("PACF for", variable_names[i]))
}

```


## Unit root tests ##
To test for the timeseries being stationary, I apply an Augmented Dickey Fuller (ADF) test, by using the **adf()**, which tests for the presence an unit root in the time series with the chosen lag of 12 periods, since the data is monthly. @tbl-adf reports the test statistics for the ADF tests:
```{r ADF tests}
#| echo: false
#| message: false
#| warning: false
#| results: hide


# ADF Test

for (i in seq_along(variable_names)) {
  variable_name <- paste("adf", variable_names[i], sep = "_")
  assign(variable_name, adf.test(Data[, i], k=12, alternative = "stationary"))
}

adf_results <- data.frame(
  Variable = c("HICP", "IP", "CISS", "UN", "M1"),
  ADF_Statistic = c(adf_hicp$statistic, adf_ip$statistic, adf_ciss$statistic, adf_un$statistic, adf_m1$statistic),
  P_Value = c(adf_hicp$p.value, adf_ip$p.value, adf_ciss$p.value, adf_un$p.value, adf_m1$p.value),
  lags = rep(12, 5)
)

```

```{r}
#| label: tbl-adf
#| tbl-cap: ADF tests' statistics with the null hypothesis being a unit root
#| echo: false

knitr::kable(adf_results, digits = 3, align = 'c')
```
Only for inflation can I reject the possibility of an unit root being present at the 5 pct. confidence interval.

# The model
To analyze the macroeconomic and financial variables and run forecasts, a vector autoregression (VAR) model can be applied, which allows for the multivariate framework of several timeseries. 
A general VAR model with $\rho$ lags for $t=1,...,T$ can be stated as:

\begin{gather}
y_{t}	=\mu_{0}+A_{1}y_{t-1}+...+A_{\rho}y_{t-\rho}+\epsilon_{t}
\epsilon_{t}|Y_{T-1}	\sim iid\left(0_{N},\Sigma\right)
\end{gather}

Where $y_{t}=N\times1$ is a vector of observations at time $t$, $\mu_{0}=N\times1$ is a vector of constant terms, $A_{i}=N\times N$ is a vector of the autoregressive slope parameters, $\epsilon_{t}=N\times1$ is a vector of error terms, $Y_{t-1}$ is the information set and $\Sigma=N\times N$ is the covariance matrix of the error term.    

## Bayesian VAR Forecasting

## References {.unnumbered}
